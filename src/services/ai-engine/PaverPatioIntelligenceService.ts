/**
 * PaverPatioIntelligenceService - Advanced Variable Extraction with GPT-4o
 *
 * Sophisticated natural language analysis for paver patio requests using OpenAI GPT-4o.
 * Extracts comprehensive variables and identifies gaps requiring clarification.
 *
 * Features:
 * - GPT-4o powered variable extraction
 * - 15+ variable comprehensive analysis
 * - Confidence scoring per variable
 * - Gap detection for missing critical information
 * - Educational reasoning for variable importance
 */

import type { PaverPatioValues } from '../../pricing-system/core/master-formula/formula-types';

export interface PaverPatioDetectionPrompt {
  userMessage: string;
  sessionId?: string;
  conversationHistory?: ConversationMessage[];
}

export interface ConversationMessage {
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
}

export interface VariableConfirmationState {
  confirmedVariables: Partial<PaverPatioValues>;
  detectedSquareFootage?: number;
  pendingVariables: string[]; // Variables that need confirmation
  currentQuestionVariable: string | null;
  conversationPhase: 'initial_analysis' | 'confirming_variables' | 'ready_for_calculation';
  sessionId: string;
  questionCount: number; // Track number of questions asked
  maxQuestions: number; // Limit to prevent endless loops
}

export interface PaverPatioAnalysisResult {
  isPaverPatio: boolean;
  confidence: number;
  detectedSquareFootage: number | null;
  extractedVariables: Partial<PaverPatioValues>;
  variableConfidence: Record<string, number>;
  missingVariables: string[]; // Variables that need confirmation
  confirmationState: VariableConfirmationState;
  nextQuestion: string | null;
  reasoning: string;
  educationalContext?: string; // Why these variables matter
}

export class PaverPatioIntelligenceService {
  private static readonly API_ENDPOINT = 'https://api.openai.com/v1/chat/completions';
  private static readonly MODEL = 'gpt-4o';

  // Variable priority order (highest impact first)
  private static readonly VARIABLE_PRIORITY = [
    'squareFootage',
    'tearoutComplexity',
    'accessDifficulty',
    'teamSize',
    'cuttingComplexity',
    'equipmentRequired',
    'paverStyle',
    'patternComplexity',
    'obstacleRemoval',
    'overallComplexity',
    'basePreparation',
    'drainageRequirements',
    'borderTreatment',
    'materialWaste',
    'timelineConstraints'
  ];

  /**
   * Initial analysis with comprehensive variable extraction using GPT-4o
   */
  static async analyzePaverPatioRequest(input: PaverPatioDetectionPrompt): Promise<PaverPatioAnalysisResult> {
    console.log('üß† PAVER PATIO INTELLIGENCE ANALYSIS START');
    console.log(`Message: "${input.userMessage}"`);
    console.log(`Session: ${input.sessionId || 'new'}`);

    const analysisPrompt = this.buildInitialAnalysisPrompt(input);

    try {
      const response = await this.callGPT4oAPI(analysisPrompt);
      const result = JSON.parse(response);

      // Identify missing variables based on priority and extraction success
      const missingVariables = this.identifyMissingVariables(result.extractedVariables, result.detectedSquareFootage);

      // Create confirmation state
      const confirmationState: VariableConfirmationState = {
        confirmedVariables: result.extractedVariables,
        detectedSquareFootage: result.detectedSquareFootage,
        pendingVariables: missingVariables,
        currentQuestionVariable: missingVariables[0] || null,
        conversationPhase: missingVariables.length > 0 ? 'confirming_variables' : 'ready_for_calculation',
        sessionId: input.sessionId || this.generateSessionId(),
        questionCount: 0,
        maxQuestions: 8 // Reasonable limit to prevent customer fatigue
      };

      console.log('üß† ANALYSIS COMPLETE:');
      console.log(`  Paver Patio: ${result.isPaverPatio ? '‚úÖ DETECTED' : '‚ùå NOT DETECTED'}`);
      console.log(`  Confidence: ${(result.confidence * 100).toFixed(1)}%`);
      console.log(`  Square Footage: ${result.detectedSquareFootage || 'NOT DETECTED'}`);
      console.log(`  Variables Extracted: ${Object.keys(result.extractedVariables).length}`);
      console.log(`  Missing Variables: ${missingVariables.length}`);
      console.log(`  Next Phase: ${confirmationState.conversationPhase}`);

      return {
        isPaverPatio: result.isPaverPatio,
        confidence: result.confidence,
        detectedSquareFootage: result.detectedSquareFootage,
        extractedVariables: result.extractedVariables,
        variableConfidence: result.variableConfidence,
        missingVariables,
        confirmationState,
        nextQuestion: null, // Will be generated by PaverPatioQuestionService
        reasoning: result.reasoning,
        educationalContext: result.educationalContext
      };

    } catch (error) {
      console.error('‚ùå GPT-4o ANALYSIS FAILED:', error);
      return this.getFallbackAnalysis(input.userMessage);
    }
  }

  /**
   * Process user response to variable confirmation question
   */
  static async processVariableConfirmation(
    userResponse: string,
    currentState: VariableConfirmationState,
    questionVariable: string
  ): Promise<VariableConfirmationState> {
    console.log(`üîç PROCESSING VARIABLE CONFIRMATION: ${questionVariable}`);
    console.log(`User Response: "${userResponse}"`);

    try {
      // Extract variable value from user response using GPT-4o
      const extractedValue = await this.extractVariableFromResponse(userResponse, questionVariable);

      // Update confirmed variables
      const updatedConfirmed = { ...currentState.confirmedVariables };
      this.setNestedVariable(updatedConfirmed, questionVariable, extractedValue);

      // Remove from pending list
      const remainingPending = currentState.pendingVariables.filter(v => v !== questionVariable);

      // Determine next variable (respect priority order)
      const nextVariable = remainingPending.length > 0 ? remainingPending[0] : null;

      // Check if we should continue asking questions
      const shouldContinue = remainingPending.length > 0 &&
                            currentState.questionCount < currentState.maxQuestions &&
                            this.shouldAskNextQuestion(updatedConfirmed, remainingPending);

      const phase = shouldContinue ? 'confirming_variables' : 'ready_for_calculation';

      console.log('üîç CONFIRMATION PROCESSED:');
      console.log(`  Variable: ${questionVariable} = ${extractedValue}`);
      console.log(`  Remaining: ${remainingPending.length} variables`);
      console.log(`  Next Variable: ${nextVariable || 'NONE'}`);
      console.log(`  Phase: ${phase}`);

      return {
        confirmedVariables: updatedConfirmed,
        detectedSquareFootage: currentState.detectedSquareFootage,
        pendingVariables: remainingPending,
        currentQuestionVariable: shouldContinue ? nextVariable : null,
        conversationPhase: phase,
        sessionId: currentState.sessionId,
        questionCount: currentState.questionCount + 1,
        maxQuestions: currentState.maxQuestions
      };

    } catch (error) {
      console.error('‚ùå VARIABLE CONFIRMATION FAILED:', error);

      // Graceful degradation - move to next variable
      const remainingPending = currentState.pendingVariables.filter(v => v !== questionVariable);
      return {
        ...currentState,
        pendingVariables: remainingPending,
        currentQuestionVariable: remainingPending[0] || null,
        conversationPhase: remainingPending.length === 0 ? 'ready_for_calculation' : 'confirming_variables',
        questionCount: currentState.questionCount + 1
      };
    }
  }

  /**
   * Build comprehensive initial analysis prompt for GPT-4o
   */
  private static buildInitialAnalysisPrompt(input: PaverPatioDetectionPrompt): string {
    const conversationContext = input.conversationHistory?.length > 0
      ? `\n\nCONVERSATION HISTORY:\n${input.conversationHistory.map(msg => `${msg.role.toUpperCase()}: ${msg.content}`).join('\n')}`
      : '';

    return `You are an expert paver patio project analyst with 20+ years of experience. Analyze the user's request and extract ALL possible variables for accurate pricing using the master formula calculation system.

USER MESSAGE: "${input.userMessage}"${conversationContext}

EXTRACTION GUIDELINES:

Your task is to identify if this is a paver patio request and extract as many variables as possible with confidence scores. Be conservative - only extract what you can reasonably infer from the text.

VARIABLES TO EXTRACT:

1. SQUARE FOOTAGE (CRITICAL):
   - Direct mentions: "200 sqft", "300 square feet"
   - Dimensions: "20x15" = 300, "12 by 10" = 120
   - Descriptive: "small patio" ‚âà 150, "medium patio" ‚âà 250, "large patio" ‚âà 400
   - Only extract if explicitly mentioned or calculable

2. TEAROUT COMPLEXITY (HIGH IMPACT):
   - "grass", "sod", "lawn" ‚Üí 'grass'
   - "concrete", "existing patio", "demo", "removal" ‚Üí 'concrete'
   - "asphalt", "pavement", "blacktop" ‚Üí 'asphalt'
   - Only extract if removal type is mentioned

3. ACCESS DIFFICULTY (HIGH IMPACT):
   - "easy access", "driveway access", "open area" ‚Üí 'easy'
   - "tight", "narrow gate", "backyard", "moderate access" ‚Üí 'moderate'
   - "very tight", "hand carry", "difficult access", "no equipment access" ‚Üí 'difficult'
   - Only extract if access conditions are described

4. TEAM SIZE PREFERENCE (HIGH IMPACT):
   - "small crew", "2-person", "minimal crew" ‚Üí 'twoPerson'
   - "full crew", "3+ people", "standard crew", "crew of 3" ‚Üí 'threePlus'
   - Only extract if team size preferences mentioned

5. CUTTING COMPLEXITY (MEDIUM IMPACT):
   - "straight edges", "simple", "rectangular", "square" ‚Üí 'minimal'
   - "some curves", "moderate cutting", "angled edges" ‚Üí 'moderate'
   - "complex shapes", "lots of cutting", "intricate design" ‚Üí 'complex'
   - Only extract if shape/cutting complexity mentioned

6. EQUIPMENT REQUIRED (MEDIUM IMPACT):
   - "hand tools", "manual work", "small job" ‚Üí 'handTools'
   - "jackhammer", "demo equipment", "pneumatic tools" ‚Üí 'attachments'
   - "small excavator", "bobcat", "light machinery" ‚Üí 'lightMachinery'
   - "excavator", "heavy equipment" ‚Üí 'heavyMachinery'
   - Only extract if equipment needs mentioned

7. PAVER STYLE (MEDIUM IMPACT):
   - "basic", "standard", "budget", "economy grade" ‚Üí 'economy'
   - "premium", "high-quality", "designer", "natural stone" ‚Üí 'premium'
   - Only extract if quality preferences mentioned

8. PATTERN COMPLEXITY (LOWER IMPACT):
   - "simple pattern", "running bond", "basic layout" ‚Üí 'minimal'
   - "herringbone", "pattern work", "decorative" ‚Üí 'some'
   - "complex patterns", "multiple patterns", "intricate design" ‚Üí 'extensive'
   - Only extract if pattern preferences mentioned

9. OBSTACLE REMOVAL (LOWER IMPACT):
   - "clear area", "no obstacles" ‚Üí 'none'
   - "few shrubs", "small plants", "minor obstacles" ‚Üí 'minor'
   - "trees", "large shrubs", "structures", "major obstacles" ‚Üí 'major'
   - Only extract if obstacles mentioned

10. OVERALL COMPLEXITY (CONTEXTUAL):
    - Simple rectangular patio, basic conditions ‚Üí 1.0
    - Standard project with some complexity ‚Üí 1.1
    - Complex design or difficult conditions ‚Üí 1.3
    - Extreme complexity or multiple challenges ‚Üí 1.5

CONFIDENCE SCORING:
- High confidence (0.8-1.0): Explicitly mentioned with clear details
- Medium confidence (0.5-0.7): Strong implications or partial information
- Low confidence (0.3-0.4): Weak implications or educated guesses
- Don't extract (0.0-0.2): Insufficient information

RESPOND WITH VALID JSON:
{
  "isPaverPatio": boolean,
  "confidence": number (0.0-1.0),
  "detectedSquareFootage": number | null,
  "extractedVariables": {
    "excavation": {
      "tearoutComplexity": string | null,
      "equipmentRequired": string | null
    },
    "siteAccess": {
      "accessDifficulty": string | null,
      "obstacleRemoval": string | null
    },
    "materials": {
      "paverStyle": string | null,
      "cuttingComplexity": string | null,
      "patternComplexity": string | null
    },
    "labor": {
      "teamSize": string | null
    },
    "complexity": {
      "overallComplexity": number | null
    }
  },
  "variableConfidence": {
    // Include confidence (0.0-1.0) for each extracted variable
  },
  "reasoning": "Detailed explanation of what was detected and confidence levels",
  "educationalContext": "Brief explanation of why these variables matter for accurate pricing"
}

EXAMPLE INPUT: "I need a 20x15 paver patio removing existing concrete with tight access"
EXAMPLE OUTPUT: {
  "isPaverPatio": true,
  "confidence": 0.95,
  "detectedSquareFootage": 300,
  "extractedVariables": {
    "excavation": {
      "tearoutComplexity": "concrete",
      "equipmentRequired": null
    },
    "siteAccess": {
      "accessDifficulty": "difficult",
      "obstacleRemoval": null
    },
    "materials": {
      "paverStyle": null,
      "cuttingComplexity": null,
      "patternComplexity": null
    },
    "labor": {
      "teamSize": null
    },
    "complexity": {
      "overallComplexity": 1.2
    }
  },
  "variableConfidence": {
    "tearoutComplexity": 0.9,
    "accessDifficulty": 0.8,
    "overallComplexity": 0.7
  },
  "reasoning": "Clear paver patio request with specific dimensions (300 sqft), concrete removal mentioned, and tight access described. Overall complexity elevated due to concrete removal and access constraints.",
  "educationalContext": "Square footage drives material costs, tearout type affects labor time significantly, and access difficulty impacts crew efficiency and timeline."
}

ANALYZE THE MESSAGE:`;
  }

  /**
   * Call GPT-4o API for analysis
   */
  private static async callGPT4oAPI(prompt: string): Promise<string> {
    const apiKey = this.getAPIKey();

    const requestBody = {
      model: this.MODEL,
      messages: [
        {
          role: 'user',
          content: prompt
        }
      ],
      temperature: 0.1,
      max_tokens: 2000
    };

    console.log('ü§ñ GPT-4o API REQUEST:', {
      model: requestBody.model,
      temperature: requestBody.temperature,
      promptLength: prompt.length,
      apiKeyMasked: `${apiKey.substring(0, 8)}...${apiKey.substring(apiKey.length - 4)}`
    });

    const response = await fetch(this.API_ENDPOINT, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(requestBody)
    });

    if (!response.ok) {
      throw new Error(`OpenAI API error: ${response.status} ${response.statusText}`);
    }

    const data = await response.json();

    if (!data.choices || data.choices.length === 0) {
      throw new Error('No response from OpenAI API');
    }

    console.log('ü§ñ GPT-4o API RESPONSE:', {
      usage: data.usage,
      responseLength: data.choices[0].message.content.length
    });

    return data.choices[0].message.content;
  }

  /**
   * Extract variable value from user response using GPT-4o
   */
  private static async extractVariableFromResponse(userResponse: string, variableName: string): Promise<any> {
    const extractionPrompt = this.buildExtractionPrompt(userResponse, variableName);

    try {
      const response = await this.callGPT4oAPI(extractionPrompt);
      const result = JSON.parse(response);

      console.log(`üîç VARIABLE EXTRACTION: ${variableName} = ${result.value} (confidence: ${result.confidence})`);

      return result.value;
    } catch (error) {
      console.error('‚ùå VARIABLE EXTRACTION FAILED:', error);
      return null;
    }
  }

  /**
   * Build extraction prompt for specific variable
   */
  private static buildExtractionPrompt(userResponse: string, variableName: string): string {
    const extractionRules = {
      squareFootage: {
        description: "Extract numeric square footage from response",
        validValues: "Any positive number",
        examples: "'about 200' ‚Üí 200, '15x20' ‚Üí 300, 'medium size' ‚Üí 250"
      },
      tearoutComplexity: {
        description: "Extract what needs to be removed",
        validValues: "'grass', 'concrete', 'asphalt'",
        examples: "'concrete' ‚Üí 'concrete', 'existing stuff' ‚Üí 'concrete', 'just grass' ‚Üí 'grass'"
      },
      accessDifficulty: {
        description: "Extract access difficulty level",
        validValues: "'easy', 'moderate', 'difficult'",
        examples: "'tight gate' ‚Üí 'difficult', 'drive right up' ‚Üí 'easy', 'some maneuvering' ‚Üí 'moderate'"
      },
      teamSize: {
        description: "Extract preferred team size",
        validValues: "'twoPerson', 'threePlus'",
        examples: "'small crew' ‚Üí 'twoPerson', 'full team' ‚Üí 'threePlus', 'quick job' ‚Üí 'twoPerson'"
      },
      cuttingComplexity: {
        description: "Extract cutting/shape complexity",
        validValues: "'minimal', 'moderate', 'complex'",
        examples: "'straight edges' ‚Üí 'minimal', 'some curves' ‚Üí 'moderate', 'lots of cutting' ‚Üí 'complex'"
      },
      equipmentRequired: {
        description: "Extract equipment needs",
        validValues: "'handTools', 'attachments', 'lightMachinery', 'heavyMachinery'",
        examples: "'hand tools' ‚Üí 'handTools', 'jackhammer' ‚Üí 'attachments', 'excavator' ‚Üí 'lightMachinery'"
      },
      paverStyle: {
        description: "Extract paver quality preference",
        validValues: "'economy', 'premium'",
        examples: "'basic pavers' ‚Üí 'economy', 'high quality' ‚Üí 'premium', 'standard' ‚Üí 'economy'"
      },
      patternComplexity: {
        description: "Extract pattern complexity",
        validValues: "'minimal', 'some', 'extensive'",
        examples: "'simple pattern' ‚Üí 'minimal', 'herringbone' ‚Üí 'some', 'complex design' ‚Üí 'extensive'"
      },
      obstacleRemoval: {
        description: "Extract obstacle removal needs",
        validValues: "'none', 'minor', 'major'",
        examples: "'clear area' ‚Üí 'none', 'few shrubs' ‚Üí 'minor', 'large tree' ‚Üí 'major'"
      },
      overallComplexity: {
        description: "Extract overall project complexity",
        validValues: "Number between 1.0-1.5",
        examples: "'simple project' ‚Üí 1.0, 'standard' ‚Üí 1.1, 'complex' ‚Üí 1.3, 'very complex' ‚Üí 1.5"
      }
    };

    const rules = extractionRules[variableName] || {
      description: `Extract ${variableName} value`,
      validValues: "Appropriate value for this variable",
      examples: "Context-appropriate extraction"
    };

    return `Extract the ${variableName} value from this user response.

VARIABLE: ${variableName}
DESCRIPTION: ${rules.description}
VALID VALUES: ${rules.validValues}
EXAMPLES: ${rules.examples}

USER RESPONSE: "${userResponse}"

Extract the most appropriate value based on the user's response. If the response is unclear or doesn't contain relevant information, return null.

RESPOND WITH JSON:
{
  "value": extracted_value_or_null,
  "confidence": number_between_0_and_1,
  "reasoning": "brief explanation of extraction"
}

EXTRACT THE VALUE:`;
  }

  /**
   * Identify missing variables that require confirmation
   */
  private static identifyMissingVariables(extractedVariables: any, detectedSquareFootage?: number): string[] {
    const missing: string[] = [];

    // Always need square footage
    if (!detectedSquareFootage) {
      missing.push('squareFootage');
    }

    // Check each variable in priority order
    for (const variable of this.VARIABLE_PRIORITY) {
      if (variable === 'squareFootage') continue; // Already checked

      const value = this.getNestedValue(extractedVariables, variable);
      if (!value) {
        missing.push(variable);
      }
    }

    // Limit to most important variables to avoid customer fatigue
    return missing.slice(0, 6);
  }

  /**
   * Determine if we should ask the next question based on current state
   */
  private static shouldAskNextQuestion(confirmedVariables: any, remainingVariables: string[]): boolean {
    // Always ask for critical variables
    const criticalVariables = ['squareFootage', 'tearoutComplexity', 'accessDifficulty'];
    const hasCriticalMissing = remainingVariables.some(v => criticalVariables.includes(v));

    if (hasCriticalMissing) return true;

    // Stop if we have enough variables for reasonable accuracy
    const confirmedCount = this.countConfirmedVariables(confirmedVariables);
    return confirmedCount < 4; // Minimum 4 variables for good accuracy
  }

  /**
   * Count confirmed variables
   */
  private static countConfirmedVariables(variables: any): number {
    let count = 0;

    function countNested(obj: any) {
      for (const key in obj) {
        if (obj[key] !== null && obj[key] !== undefined) {
          if (typeof obj[key] === 'object' && !Array.isArray(obj[key])) {
            countNested(obj[key]);
          } else {
            count++;
          }
        }
      }
    }

    countNested(variables);
    return count;
  }

  /**
   * Get nested value from object using dot notation
   */
  private static getNestedValue(obj: any, path: string): any {
    const keys = path.split('.');
    let current = obj;
    for (const key of keys) {
      if (!current || current[key] === undefined) return null;
      current = current[key];
    }
    return current;
  }

  /**
   * Set nested value in object using dot notation
   */
  private static setNestedVariable(obj: any, path: string, value: any): void {
    const keys = path.split('.');
    let current = obj;

    for (let i = 0; i < keys.length - 1; i++) {
      const key = keys[i];
      if (!current[key] || typeof current[key] !== 'object') {
        current[key] = {};
      }
      current = current[key];
    }

    current[keys[keys.length - 1]] = value;
  }

  /**
   * Get API key from environment
   */
  private static getAPIKey(): string {
    const getEnvVar = (key: string): string | undefined => {
      if (typeof process !== 'undefined' && process.env && process.env[key]) {
        return process.env[key];
      }
      try {
        if (typeof import.meta !== 'undefined' && import.meta?.env?.[key]) {
          return import.meta.env[key];
        }
      } catch (e) {
        // import.meta not available
      }
      return undefined;
    };

    const apiKey = getEnvVar('VITE_OPENAI_API_KEY_MINI') || getEnvVar('VITE_AI_API_KEY');

    if (!apiKey) {
      throw new Error('OpenAI API key not found. Set VITE_OPENAI_API_KEY_MINI environment variable.');
    }

    return apiKey;
  }

  /**
   * Generate unique session ID
   */
  private static generateSessionId(): string {
    return `paver_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;
  }

  /**
   * Fallback analysis when GPT-4o fails
   */
  private static getFallbackAnalysis(userMessage: string): PaverPatioAnalysisResult {
    console.log('üîÑ FALLBACK: Using basic rule-based analysis');

    const lowerMessage = userMessage.toLowerCase();
    const isPaverPatio = /\b(?:paver|patio|stone)\s+patio\b/.test(lowerMessage);

    // Basic square footage extraction
    const sqftMatch = lowerMessage.match(/(\d+)\s*(?:sq\.?\s*ft\.?|sqft|square\s+feet)/);
    const dimensionMatch = lowerMessage.match(/(\d+)\s*x\s*(\d+)/);

    let detectedSquareFootage = null;
    if (sqftMatch) {
      detectedSquareFootage = parseInt(sqftMatch[1]);
    } else if (dimensionMatch) {
      detectedSquareFootage = parseInt(dimensionMatch[1]) * parseInt(dimensionMatch[2]);
    }

    const confirmationState: VariableConfirmationState = {
      confirmedVariables: {},
      detectedSquareFootage,
      pendingVariables: detectedSquareFootage ? ['tearoutComplexity', 'accessDifficulty'] : ['squareFootage', 'tearoutComplexity', 'accessDifficulty'],
      currentQuestionVariable: detectedSquareFootage ? 'tearoutComplexity' : 'squareFootage',
      conversationPhase: 'confirming_variables',
      sessionId: this.generateSessionId(),
      questionCount: 0,
      maxQuestions: 8
    };

    return {
      isPaverPatio,
      confidence: isPaverPatio ? 0.6 : 0.1,
      detectedSquareFootage,
      extractedVariables: {},
      variableConfidence: {},
      missingVariables: confirmationState.pendingVariables,
      confirmationState,
      nextQuestion: null,
      reasoning: 'Fallback analysis due to GPT-4o API failure',
      educationalContext: 'Using basic pattern matching for initial assessment'
    };
  }
}